<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>KnightCTF - Knight Switch bank </title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
	background-color:rgb(55, 53, 47);
	color: white;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		background-color:rgb(55, 53, 47);
		color: white;
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid white;
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;

}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="d93bca6f-8d8d-4794-8f19-62e8fe10262f" class="page sans"><header><h1 class="page-title">KnightCTF - Knight Switch bank </h1></header><div class="page-body"><p id="9193ef02-b215-4f1a-807a-81eccff19960" class="">
</p><table id="d7425858-b507-48c4-abbe-31bb63392eff" class="simple-table"><tbody><tr id="0003b468-9d34-454f-9f70-c106eb78fca3"><td id="rfFO">Nom</td><td id="u^@;">Knight Switch Bank</td></tr><tr id="05e0d23c-565e-4e89-b3a3-c617c2f5d1a9"><td id="rfFO">Points</td><td id="u^@;">200</td></tr><tr id="a4a07975-a82d-496c-bc0a-973b85698828"><td id="rfFO">Difficulté </td><td id="u^@;">Facile</td></tr><tr id="22a56a47-eb91-4bb8-ac49-7ad69a033224"><td id="rfFO">Validation</td><td id="u^@;">173</td></tr></tbody></table><p id="d0bce5e9-53fc-4faf-863b-3f5f0b92e07e" class="">Bonjour, je vous présente aujourd’hui ma writeup sur le challenge de Reverse Knight Switch bank du CTF KnightCTF.</p><p id="1ab2eead-7315-42a5-8e88-0f8c9eb79ba2" class="">
</p><p id="385b1f34-3202-4267-b4d9-c7bd74a9ca7d" class="">Commençons par le commencement, tout d’abord lançons le binaire.</p><figure id="925d96a4-f750-4cb5-a23f-cb0d7a2d40c0" class="image"><a href="images/Untitled.png"><img style="width:978px" src="images/Untitled.png"/></a></figure><p id="cd95882b-f022-4732-a169-23e614e58184" class="">
</p><h2 id="b8af4a8c-840f-4663-a0b3-7d6f999ac5a6" class="">Analyse et compréhensions du binaire</h2><p id="491c0d0a-558b-46a5-8906-db22f87e077d" class="">Lorsque nous lançons le binaire on peut voir qu’il demande un mot de passe. On peut potentiellement en conclure que le mot de passe est en dur dans le code du binaire, mais qu’il y a un algorithme à reverse. C’est partit récupérons le pseudo code.</p><p id="5b67a89a-4055-47eb-8524-01b541042018" class="">
</p><table id="694acde4-79b6-4f2b-b863-a79c3838b5b6" class="simple-table"><tbody><tr id="88c7e638-9cd0-4c25-8743-702d8d225e7c"><td id="]SSG">Fonctions du binaire</td></tr><tr id="9ef222b5-b441-48ed-8235-9db6fcf96197"><td id="]SSG">main</td></tr><tr id="11e4c95d-48a2-4c57-899c-dd681e70b765"><td id="]SSG">winner</td></tr></tbody></table><p id="074877ed-a02d-4f65-ae47-5c275d5ba107" class="">
</p><p id="f626d0b6-dd8d-4cf3-821b-41e306689ca2" class="">En effet on peut obsérver qu’il existe seulement deux fonctions dans le binaire. En allant voir dans le winner j’ai vu que cela affichait simplement une chaine de caractère m’indiquant que le mot de passe rentré était correct. Nous allons donc analyser la fonction main.</p><p id="c7416b37-db74-4ece-b164-b260a6e11df8" class="">
</p><p id="037b3545-5d6a-48fe-9975-98f83e9a8170" class="">Main: </p><pre id="d35013ba-5cea-4f3e-a269-39fd14d4b10b" class="code"><code>undefined8 main(void)
{
    int64_t var_430h;
    int64_t var_230h;
    int64_t var_30h;
    int64_t var_28h;
    int64_t var_20h;
    int64_t var_18h;
    int32_t var_10h;
    char var_9h;
    int32_t var_8h;
    int64_t var_4h;
    
    var_30h = 0x4164485d5549525a;
    var_28h = 0x41494447414a644e;
    var_20h = 0x4173444476414978;
    var_18h._0_4_ = 0x71444479;
    var_18h._4_2_ = 0x5f;
    var_4h._0_4_ = 0;
    var_8h = 0;
    puts(0x402008);
    puts(&quot;\tKnight Switch Bank&quot;);
    puts(0x402048);
    puts(&quot;Welcome to Knight Switch Bank....&quot;);
    printf(&quot;Please enter your password : &quot;);
    __isoc99_scanf(0x402130, &amp;var_230h);
    for (; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) != &#x27;\0&#x27;; var_4h._0_4_ = (int32_t)var_4h + 1) {
        if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;A&#x27;) ||
           (&#x27;M&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
            if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;a&#x27;) ||
               (&#x27;m&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;N&#x27;) ||
                   (&#x27;Z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                    if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;n&#x27;) ||
                       (&#x27;z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;
                    } else {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                    }
                } else {
                    *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                         *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                }
            } else {
                *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
            }
        } else {
            *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
        }
    }
    for (; *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) != &#x27;\0&#x27;; var_8h = var_8h + 1) {
        *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) = *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) + &#x27;\x02&#x27;;
    }
    var_9h = &#x27;\0&#x27;;
    var_10h = 0;
    do {
        if (*(char *)((int64_t)&amp;var_30h + (int64_t)var_10h) == &#x27;\0&#x27;) {
code_r0x00401437:
            if (var_9h == &#x27;\0&#x27;) {
                puts(&quot;Oh My God ! You entered a wrong password.&quot;);
            } else {
                winner();
            }
            return 0;
        }
        if (*(char *)((int64_t)&amp;var_30h + (int64_t)var_10h) != *(char *)((int64_t)&amp;var_430h + (int64_t)var_10h)) {
            var_9h = &#x27;\0&#x27;;
            goto code_r0x00401437;
        }
        var_9h = &#x27;\x01&#x27;;
        var_10h = var_10h + 1;
    } while( true );
}</code></pre><p id="f552cc92-a587-441b-bd84-36db9907a65c" class="">
</p><p id="534bb1fa-2605-41dc-90cc-2a9e8c59c198" class="">Voilà donc le contenu de notre fonction main. Je vous propose d’analyser le code étape par étape.</p><p id="61b5fb4f-edc8-4a0c-a490-83f4e78a8ea7" class="">
</p><p id="efa76654-2d2d-4bd2-8edf-e07de469097b" class="">Je vais vous épargner les déclarations de variables ce serait inutile allons directement à l’essentiel.</p><p id="2247f316-4d42-4c28-8f43-f1e4736bb364" class="">
</p><h3 id="2daaf3fd-e698-46f8-a418-c963be0f0b98" class="">1 ère étape de l’algorithme</h3><pre id="d25e5684-f76e-40ee-942b-32e0d7287ce4" class="code"><code>		var_30h = 0x4164485d5549525a;
    var_28h = 0x41494447414a644e;
    var_20h = 0x4173444476414978;
    var_18h._0_4_ = 0x71444479;
    var_18h._4_2_ = 0x5f;
    var_4h._0_4_ = 0;
    var_8h = 0;
    puts(0x402008);
    puts(&quot;\tKnight Switch Bank&quot;);
    puts(0x402048);
    puts(&quot;Welcome to Knight Switch Bank....&quot;);
    printf(&quot;Please enter your password : &quot;);
    __isoc99_scanf(0x402130, &amp;var_230h);
    for (; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) != &#x27;\0&#x27;; var_4h._0_4_ = (int32_t)var_4h + 1) {
        if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;A&#x27;) ||
           (&#x27;M&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
            if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;a&#x27;) ||
               (&#x27;m&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;N&#x27;) ||
                   (&#x27;Z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                    if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;n&#x27;) ||
                       (&#x27;z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;
                    } else {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                    }
                } else {
                    *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                         *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                }
            } else {
                *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
            }
        } else {
            *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
        }
    }</code></pre><p id="fb1239df-d5cb-4c6c-bc3f-09558815fadd" class="">
</p><p id="3d32cc72-6df3-4cd7-920a-c9300438d73c" class="">Comme vous pouvez le voir il y a tout d’abord des initialisation de variable on peut donc en conclure assez facilement que ce sont potentiellement les chaines correspondant au flag.</p><p id="6d4375f4-08e5-4afe-9908-1061c8f5db0d" class="">Mais nous verrons à la fin si c’est bien cela.</p><p id="f15b6a12-4292-419f-9978-28d956764677" class="">
</p><p id="03971c40-7e0f-49d1-b291-9d37f76673c9" class="">Ensuite si on lit bien le code on voit qu’il fait un simple scanf il va simplement mettre le contenu que l’on écrit dans le STDIN dans le buffer.</p><p id="eaa99e6d-8b1f-4f06-a3ac-92e087ba38f2" class="">
</p><pre id="52530879-a77e-41be-bccb-37f9b461202c" class="code"><code>for (; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) != &#x27;\0&#x27;; var_4h._0_4_ = (int32_t)var_4h + 1) {
        if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;A&#x27;) ||
           (&#x27;M&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
            if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;a&#x27;) ||
               (&#x27;m&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;N&#x27;) ||
                   (&#x27;Z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                    if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;n&#x27;) ||
                       (&#x27;z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;
                    } else {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                    }
                } else {
                    *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                         *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                }
            } else {
                *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
            }
        } else {
            *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
        }
    }</code></pre><p id="21b034b2-701c-4cff-b6f9-075a75be65a8" class="">
</p><p id="4cf4ca67-e5a4-46c9-b845-a9b0fe3a42cf" class="">En effet rappelez vous notre variable du buffer s’appelle var_230h. Le code ci-dessus est plutot simple nous allons simplement parcourirs la chaine rentré dans le scanf. D’ou la boucle for dans cette boucle il va y avoir des actions très intéressante. Alors écoutez bien.</p><p id="b2887d68-148a-44ce-97d2-0a24ceba9933" class="">
</p><p id="f74c7302-4499-45f4-ab65-7016f270e6e7" class="">Tout d’abord la première vérification est super simple il va regarder si la valeur de notre caractère n’est pas comprise entre ‘A’ et ‘M’ si ce n’est pas le cas et bien il va prendre une variable qu’il aura initialisé juste avant la boucle et il y inserera la somme de notre caractère + ‘\r’</p><p id="4297a98c-97fe-412a-8fef-9eca6c86b772" class="">
</p><pre id="88f9a50a-e735-417f-83c3-ca44cac4e62b" class="code"><code>*(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;</code></pre><p id="3f4e66ff-7fe6-4c78-907c-9cdf2a0d48f9" class="">
</p><pre id="c4887ba7-e25f-43cc-a54d-cdf5a2ceea1a" class="code"><code>input = &#x27;K&#x27; // K est bien dans l&#x27;interval de A et M donc il rentrera dans le else

result = ord(input)+ord(&#x27;\r&#x27;) // soit 75+13
//=&gt; 88</code></pre><p id="fbee7d58-35d5-4473-b548-284096e143bd" class="">
</p><p id="21cb5a29-1a77-4939-a788-01c28efa2707" class="">Donc voilà ça c’est l’opération qui ce passera seulement si le caractère est compris entre ‘A’ et ‘M’</p><p id="34581d12-c073-4bd3-a168-1b23110d3bde" class="">
</p><p id="2e339f64-5818-40f9-a00e-793e31cc37b4" class="">En revanche si celui-ci n’est pas contenu entre les deux l’algorithme va rentrer dans une autre condition qui vérifie si idem la lettre n’est pas contenu entre ‘a’ et ‘m’ si tel est le cas il refait la même opération que pour le premier.</p><p id="ccf6268c-2ea8-439d-9338-3327f6ff88f0" class="">
</p><p id="6dc018ab-7005-4566-828d-d0284a08ac25" class="">Si du coup le caractère n’est pas compris entre ‘a’ et ‘m’ il rentre dans une condition verifiant si le caractère n’est pas compris entre ‘N’ et ‘Z’ si le caractère en question est compris entre ‘N’ et ‘Z’ nous rentrons dans le else.</p><p id="156b3e34-119d-4d7e-8354-b21171f6b416" class="">
</p><pre id="6a222ea9-c4a9-4a51-9d61-d0fc0b841aa3" class="code"><code>*(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
              *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
             </code></pre><p id="3d511e26-3737-4de7-b545-16fec18f56e9" class="">
</p><p id="8633aeb0-a08b-4b02-9b35-9632ecb9c3bd" class="">Rien de bien compliquer, il prend le caractère actuel et il le soustrait à 0xd.</p><p id="99fedef3-885f-415b-8a8c-bf5c0c117f15" class="">Petit exemple en pseudo code.</p><p id="53596dac-60c3-4563-b7ca-51fe5d75bf2f" class="">
</p><pre id="f9f5aec5-95f5-445f-88e5-9be878aafc08" class="code"><code>input = &#x27;X&#x27;
result = ord(input)-0xd // soit 88-0xd ou 88-1
//=&gt; 75</code></pre><p id="b6f87cff-caf5-410c-92df-c0ce4fbe5356" class="">
</p><p id="2fc61c22-877b-46a7-99f0-e76e6742cd08" class="">Et il fait également la même procédure pour les minuscule. Maintenant si toute ces conditions sont correctes. Il soustrait 0x20 au caracère actuel, c’est dans le cas ou y a des caractères spéciaux.</p><p id="1d8cebcd-899f-4cd4-883b-b40bc3a0cadb" class="">
</p><pre id="af82b9ad-002e-41bf-aaab-d466979015ff" class="code"><code>*(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;</code></pre><p id="d2824dc4-395b-4e0c-acfe-48a799fa6440" class="">
</p><pre id="ffe67e97-2bf9-4015-a1b0-eee5e9084325" class="code"><code>input = &#x27;{&#x27;

result = ord(input)-0x20 // soit 123-0x20
//=&gt; 91</code></pre><p id="b22796b0-3805-4349-8b30-01f415e76f2a" class="">
</p><p id="51306af4-bebc-4776-940e-55b31072edab" class="">Parfait nous avons donc réussi à comprendre la première étape de l’algorithme.</p><h3 id="998e19f2-7081-4e85-93ad-d1079b2969ad" class="">2 ème étape de l’algorithme</h3><p id="90b7b32f-c4b2-4a58-b7bf-3b5df52e6038" class="">La deuxième étape est la plus simple de toute car elle ne comporte que très peu de code.</p><p id="297cfa16-b859-4967-b687-a44cd0edb989" class="">
</p><pre id="965dd14d-57fa-4b36-8b73-5e006afbd0c2" class="code"><code>for (; *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) != &#x27;\0&#x27;; var_8h = var_8h + 1) {
    *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) = 
							*(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) + &#x27;\x02&#x27;;
}</code></pre><p id="fe47f6b6-d987-4b60-924f-cede2b0642a1" class="">
</p><p id="5d6c89be-a25f-4f77-9bf2-8ec4eeadc86b" class="">Le code est très simple il va simplement parcourir toute la chaine de caractère que l’on a instancié juste avant dans la 1ère étape, il va ensuite simplement remplacer chaque caractère par le caractère actuel+ 2</p><p id="c425e87a-98ba-4cd4-a454-fd268aed1289" class="">
</p><pre id="1938932a-9243-4e46-9b48-ac95d1ef6ab7" class="code"><code>input = &#x27;A&#x27;

res = ord(input)+0x2 // 65+0x20
//=&gt; 67</code></pre><p id="6426dcd4-321a-43e2-bf06-bc6dea85f5af" class="">
</p><p id="88a02531-3c81-4de6-b531-0d94ac8d3278" class="">Y a rien de plus à dire sur cette étape c’est tout ce qu’elle fait 🙂.</p><p id="4736330e-6b5d-4ff8-9e9b-520492c40292" class="">
</p><h3 id="03071dab-2dbe-4286-8f73-0705b2b9334b" class="">3 ème étape de l’algorithme</h3><p id="531b2cc1-66ef-4fd7-a9a2-f1163ec81190" class="">Bon nous allons essayer de comprendre la 3 ème et dernière étape de l’algorithme. Elle est toute simple car ce n’est que la partie qui verifie si le flag est bon ou mauvais.</p><p id="2286de14-7e2b-4d78-98a5-34e3b6aef821" class="">
</p><pre id="924fa1a4-3e44-4bde-8ca5-377a0f43f5f8" class="code"><code>var_9h = &#x27;\0&#x27;;
    var_10h = 0;
    do {
        if (*(char *)((int64_t)&amp;var_30h + (int64_t)var_10h) == &#x27;\0&#x27;) {
code_r0x00401437:
            if (var_9h == &#x27;\0&#x27;) {
                puts(&quot;Oh My God ! You entered a wrong password.&quot;);
            } else {
                winner();
            }
            return 0;
        }
        if (*(char *)((int64_t)&amp;var_30h + (int64_t)var_10h) != *(char *)((int64_t)&amp;var_430h + (int64_t)var_10h)) {
            var_9h = &#x27;\0&#x27;;
            goto code_r0x00401437;
        }
        var_9h = &#x27;\x01&#x27;;
        var_10h = var_10h + 1;
    } while( true );</code></pre><p id="358da731-a0a2-4e82-8861-f41d662145fe" class="">
</p><p id="9202941c-affc-487c-a8df-b12a026f8941" class="">Je ne vais pas trop m’attarder car le code est relativement compréhensible. Mais en gros on va itérer sur la chaine qui stock une des parties du flag.</p><p id="58e157d7-132e-486a-9c5e-188676d4cfc1" class="">
</p><p id="97d59c2b-b39d-41e8-ba23-57aabf307e09" class="">Celle-ci:</p><pre id="acce3fdb-2e83-4fab-af3f-83a62dac8556" class="code"><code>var_30h = 0x4164485d5549525a;</code></pre><p id="e84f79c5-181e-4df8-89e8-525053d97dc4" class="">
</p><p id="bab4010c-4fd8-492d-a444-8a536513e02b" class="">Puis à la fin on verifie sur le caractère actuel du flag est égal au caractère actuel de notre buffer. C’est maintenant qu’on peut en conclure que var_30h et le reste stock bien notre flag. Notre mission si on l’accepte est de reverse l’algorithme.</p><p id="7f06a92e-f8d4-49f8-bfe2-31dcc4d43894" class="">
</p><h2 id="04abda09-3983-44df-b0bb-ab7fc3c6da6a" class="">Reverse l’algorithme</h2><p id="74713deb-0695-4b89-9f78-d0e9ee13804d" class="">
</p><p id="96f50438-00b5-4c31-bbcb-f26b95312b8c" class="">Ce qui est important dans cet algorithme c’est que l’on va devoir vraiment faire les étapes au sens inverse. C’est à dire que nous allons d’abord devoir reverse la 2 ème step et ensuite la 1 ère pour avoir la chaine final.</p><p id="62db2a43-1587-425f-8a29-aeccd0c51f49" class="">Avant tout on sait que notre debut de flag sera forcément KCTF{. On a donc déjà un petit indice pour l’exploitation.</p><p id="125f7eb9-4eea-420d-b0d8-a4680858e860" class="">
</p><p id="c75364a2-3197-4f77-9b1b-0051f286d777" class="">Commençons par prendre le dernier byte de var_30h étant donné que c’est censé être le ‘K’ on va facilement pouvoir comprendre comment reverse.</p><p id="fbcc0a11-7f90-4902-9d39-e3c15499842d" class="">
</p><p id="3a91de94-a164-4589-a765-c3c48c33021b" class="">flag:</p><pre id="d49b8a5d-a365-4304-bec6-90267c27a8e4" class="code"><code>var_30h = 0x4164485d5549525a;</code></pre><p id="9b175577-f4b3-4f85-9c72-ac5b56119ccc" class="">Donc reprenons notre step 2</p><pre id="ded2ed3f-2e0c-4357-8980-adc74b6f7efa" class="code"><code>for (; *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) != &#x27;\0&#x27;; var_8h = var_8h + 1) {
    *(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) = 
							*(char *)((int64_t)&amp;var_430h + (int64_t)var_8h) + &#x27;\x02&#x27;;
}</code></pre><p id="3a5e47e4-22de-45a9-bb15-69c17458ef5f" class="">Rappelez vous notre step 2 prend chaque caractère de la chaine final et lui ajoute 2. Il n’y a pas besoin d’un doctorat en mathématique pour comprendre que pour reverse cette step nous allons simplement devoir soustraire 2 à notre byte.</p><p id="342ac684-7b1e-46f7-a9dc-8a1bf60f574a" class="">
</p><pre id="6f132013-190c-4ef6-94e2-7b56383a6e5d" class="code"><code>byte = 0x5a

print((byte-0x2))
#=&gt;88 soit =&gt; &#x27;X&#x27;</code></pre><p id="aa9fe122-b2ea-4945-88f8-afad9d50487d" class="">
</p><p id="bc977dcf-4420-4203-9d6c-df4201bb7c36" class="">Parfait nous avons reverse la 2 ème step à présent il va falloir simplement que je reverse la 1 ère step c’est partit.</p><p id="02d4a82d-f536-4d80-9ee4-9995ba56989e" class="">
</p><pre id="8ea16750-b537-46ed-9460-e3054be5a02b" class="code"><code>for (; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) != &#x27;\0&#x27;; var_4h._0_4_ = (int32_t)var_4h + 1) {
        if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;A&#x27;) ||
           (&#x27;M&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
            if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;a&#x27;) ||
               (&#x27;m&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;N&#x27;) ||
                   (&#x27;Z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                    if ((*(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) &lt; &#x27;n&#x27;) ||
                       (&#x27;z&#x27; &lt; *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h))) {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0x20;
                    } else {
                        *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                             *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                    }
                } else {
                    *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                         *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + -0xd;
                }
            } else {
                *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                     *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
            }
        } else {
            *(char *)((int64_t)&amp;var_430h + (int64_t)(int32_t)var_4h) =
                 *(char *)((int64_t)&amp;var_230h + (int64_t)(int32_t)var_4h) + &#x27;\r&#x27;;
        }
    }</code></pre><p id="a43d62f9-6b7a-4fa2-83d6-ebd0d41c875e" class="">
</p><p id="b27513a7-ea12-41e4-8c67-42a9c4eafad0" class="">Donc ce que nous savons de cette partie c’est que si l’on met une lettre majuscule ou minuscule compris entre ‘a’ et ‘m’ et bien nous rentrons dans le else.</p><p id="e385a93d-15f5-4cdd-a8a3-eac2155226ba" class="">On sait que notre premier caractère est forcément ‘K’</p><p id="0fe890e2-2daa-4a95-94b0-5bd70b14aac8" class="">
</p><p id="427fdcfe-ff0f-4d7c-aab4-fe41be067a6b" class="">Alors bruteforçons voir le quel à la fin obtiendra une lettre cohérente.</p><p id="b8345155-d7b8-49da-8191-a22bb67cde9a" class="">
</p><pre id="184b4785-d8b8-47e5-b556-debb807b7ac7" class="code"><code>byte = 0x5a

print((byte-0x2)-13) # on soustrait à notre byte reversé 13 car 13 équivaut à la valeur
# ascii de &#x27;\r&#x27;
#=&gt; 75 soit &#x27;K&#x27;</code></pre><p id="cde6ab6b-42ec-45f3-8c1a-f194715e883a" class="">
</p><p id="209944fc-d32f-4249-9251-9db257b63340" class="">à présent je vous propose donc de scripter tout cela.</p><p id="b882d2dd-c4fb-40f0-bf54-764e7739ce7d" class="">
</p><h3 id="51a593a4-124a-4d27-9870-e7400c8fe542" class="">Conception d’un script permettant de reverse l’algorithme</h3><p id="5ba58f20-6f32-4486-92dc-262707ee6ec4" class="">
</p><p id="271fe01c-bb2e-4a96-b8c4-57b81c5f4947" class="">Donc en effet nous avons compris comment reverse les lettres entre ‘A’ et ‘M’ ou a et ‘m’</p><p id="2b74e793-1c24-4f7a-9a35-93fd45c6bd64" class="">
</p><p id="efff56e9-16a5-4a58-97c5-860e8451e3e5" class="">Le problème est : “Comment je vais savoir quel algorithme appliquer à ma lettre sans savoir à l’avance son range ?”. Rien de plus simple ce que j’ai fais c’est simplement de bruteforce.</p><p id="213e27cf-42c2-433d-9734-6ab663a14982" class="">
</p><p id="d19798a6-462a-4f31-87a4-3ca928c8a4b3" class="">Voici un petit exemple:</p><pre id="c148d147-b941-410a-a5e0-de13ddbb3262" class="code"><code>def step2(byte)
		return byte-0x2
end

def algo_range_a_m(byte)
		return (step2(byte)-13)
end

def algo_range_n_z(byte)
		return (step2(byte)+0xd)
end


def step1(byte)
		algo_operation1 = algo_range_a_m(byte)
		algo_operation2 = algo_range_n_z(byte)
		algo_operation3 = (step2(byte)+0x20)
	
		if (algo_operation1 &gt;= &#x27;A&#x27;.ord &amp;&amp; algo_operation1 &lt;= &#x27;M&#x27;.ord) ||(algo_operation1 &gt;= &#x27;a&#x27;.ord &amp;&amp; algo_operation1 &lt;= &#x27;m&#x27;.ord)
        return algo_operation1.chr
    elsif (algo_operation2 &gt;= &#x27;N&#x27;.ord &amp;&amp; algo_operation2 &lt;= &#x27;Z&#x27;.ord) || (algo_operation2 &gt;= &#x27;n&#x27;.ord &amp;&amp; algo_operation2 &lt;= &#x27;z&#x27;.ord)
        return algo_operation2.chr
    else
        return algo_operation3.chr
    end
end</code></pre><p id="9528c628-c3ac-4495-9dfc-a30a99ab5043" class="">
</p><p id="d53e6f0f-fef1-474f-bdd6-df0635286f1b" class="">Donc pour la petite explication je vais simplement appliquer chaque algorithme à chaque caractère et comparer en gros si par exemple le résultat est dans les ranges si tel est le cas on renvois la valeur correspondant au range.</p><p id="095d9117-fd5d-47e9-bf24-1f2cbb1255c4" class="">
</p><p id="49b16326-c785-4fa9-b3e4-4f2af6ccc4a8" class="">Voici le script de fin qui reverse nos chaines de caractères. ;)</p><p id="363f91b7-aeb2-4781-af86-54cd6839b93f" class="">
</p><pre id="1874e548-23c1-4b5b-a293-2a247ee2b1d2" class="code"><code>def step2(byte)
    return byte-0x2
end

def algo_range_a_m(byte)
    return (step2(byte)-13)
end

def algo_range_n_z(byte)
    return (step2(byte)+0xd)
end


def step1(byte)
    algo_operation1 = algo_range_a_m(byte)
    algo_operation2 = algo_range_n_z(byte)
    algo_operation3 = (step2(byte)+0x20)

    if (algo_operation1 &gt;= &#x27;A&#x27;.ord &amp;&amp; algo_operation1 &lt;= &#x27;M&#x27;.ord) ||(algo_operation1 &gt;= &#x27;a&#x27;.ord &amp;&amp; algo_operation1 &lt;= &#x27;m&#x27;.ord)
        return algo_operation1.chr
    elsif (algo_operation2 &gt;= &#x27;N&#x27;.ord &amp;&amp; algo_operation2 &lt;= &#x27;Z&#x27;.ord) || (algo_operation2 &gt;= &#x27;n&#x27;.ord &amp;&amp; algo_operation2 &lt;= &#x27;z&#x27;.ord)
        return algo_operation2.chr
    else
        return algo_operation3.chr
    end
end

def main()
    text0 = [0x41,0x64,0x48,0x5d,0x55,0x49,0x52,0x5a].reverse
    text1 = [0x41,0x49,0x44,0x47,0x41,0x4a,0x64,0x4e].reverse
    text2 = [0x41,0x73,0x44,0x44,0x76,0x41,0x49,0x78].reverse
    text3 = [0x71,0x44,0x44,0x79].reverse

    flag = []
    4.times do |i|
        tmp_flag = []

        eval(&quot;text#{i}&quot;).map.with_index do |byte, j|
            tmp_flag[j] = step1(byte)
        end

        flag[i] = tmp_flag
    end

    puts &quot;Flag: #{flag.join}}&quot;
end

if __FILE__ == $0
    main()
end</code></pre><p id="9d9e2693-fcc2-4e10-9eb4-7a01ca0634a9" class=""> </p><pre id="c509e56f-c382-447e-b2de-25a8940f6655" class="code"><code>Flag: KCTF{So_YoU_ROT_iT_gOOd_jOOb}</code></pre><p id="0beb6ff0-6e7c-4f43-b4d0-b2e78080bc26" class="">
</p><p id="7af6669e-ef63-4797-80f3-72abacfa80fd" class="">Sur ce je vous souhaite une bonne journée 🙂</p></div></article></body></html>
